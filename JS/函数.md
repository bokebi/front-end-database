# 函数

## 定义方法

1. 函数声明 function a\(\) {}
2. 函数表达式 var a = function\(\){}
3. new Function\(\['参数'\],'函数体'\)

### 立即执行函数（IIFE——Immediately Invoked Function Expression）

function\(\){}\(\)这样会出错，因为它进行了函数声明，而函数声明要求要有标识符作为函数名称，而function g\(\){ }\(\)不会执行，因为这是一个函数声明，末尾的括号被当成了分组运算符。要变成立即执行的函数，需要将函数声明变为表达式，即不用function开头。

（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义。

IIFE的作用：模仿一个私有作用域。

## 函数相关方法

### call，apply，bind

将函数作为对象的方法调用，改变函数的this指向。

三者区别在于，apply将参数以数字形式传递，bind不立即执行。

### toString，valueOf

函数的方法，返回函数的字符串表示

## 函数特性

### 参数

对传递的参数的数目和类型没有限制，内部使用arguments类数组来表示传递的参数。arguments有length属性，它的值与命名参数的值保持独立又同步。length表示期望接收的参数的个数。

参数传递的都是数值。

### 第一类对象

可以以正常数据形式存在（比方说：当参数传递，接受函数式参数或者以函数值返回）都称作第一类对象。

js中函数是第一类对象。

### 指针标识

* this 指向当前操作对象
* callee 指向参数集合所属函数
* prototype 指向函数附带的原型对象
* construct 指向创建该对象的构造函数

## 闭包

在基础知识中，提到了执行环境和活动对象的概念，闭包的形成与这些概念息息相关。

首先，我们知道函数进入执行上下文时，会对在其中定义的函数赋予一个\[\[scope\]\]属性，而这个属性的指向就是当前执行函数，所以函数的作用域是在定义时确定的。而在函数调用时，它可以通过作用域链去访问定义时所处一系列环境中的变量。

正常来说，当一个函数A执行完毕后，它的执行环境就被推出执行环境栈了。但是当一个函数A中定义的函数B被外部变量引用了（通过return 等方式），那么函数A调用完成后它的执行环境不被销毁——外部变量就可以通过函数B访问到函数A作用域内的变量了。

函数B不在函数A中调用时，访问到的函数A中的变量是函数A调用结束时的变量值。

闭包的特性：可以读取函数内部的变量，且让这些变量的值始终保持在内存中。

闭包的作用：

* 实现私有成员
* 保护命名空间
* 避免污染全局变量
* 变量需要长期驻留在内存

